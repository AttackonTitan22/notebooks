*p++等价于  *(p++)

---





array可以进行拷贝或对象赋值操作

如果在一个循环中插入/删除deque、string或vector中的元素，不要缓存end返回的迭代器。

通用版本的sort要求i随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器

---



### 第十一章

关联容器的迭代器都是双向的

一个map的value_type是一个pair<const a,b>不可以改变关键字的值

set中的关键字也是const

第7章

抑制构造函数定义的隐式转换用explicit，explicit构造函数只能用于直接初始化

---



### 第十二章

```c++
   A* a = new A;                                       
   std::shared_ptr<A> pa(a);
 
   std::shared_ptr<A> pa1 = std::make_shared<A>(1); 
```



内置类型的对象被销毁是什么也不会发生，当一个指针离开其作用域是，它所指向的对象什么也不会发生，如果这个指针指向的是动态内存，那么内存将不会被自动释放

release成员返回unique_ptr当前保存的指针并将其置为空，release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。

创建一个weak_ptr时，要用一个shared_ptr来初始化它

动态数组并不是数组类型

allocator分配未构造的内存。为了使用使用allocate返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。

当我们用完对象后，必须对每一个构造的元素调用destroy来销毁它们，destroy接受一个指针，对指向的对象执行析构函数。但是并未释放内存。

释放内存需要通过deallocate来完成

使用动态内存的一个常见原因是允许多个对象共享相同的状态

不能进行内置指针到智能指针的隐式转换，需要显式。如  shared_ptr<int>(new int(n));

那些没有默认构造函数的类就不能动态分配数组



---

### 第十三章

拷贝初始化还会发生：

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

拷贝构造函数被用来初始化非引用类型参数，就使得自己的参数必须是引用类型

析构函数不能被重载，一个类只能有唯一的一个析构函数，析构函数释放对象在生存期分配的所有资源。

隐式销毁一个内置指针类型的成员不会delete它所指向的对象

如果一个类需要自定义析构函数，几乎可以肯定它也要自定义拷贝赋值运算符和拷贝构造函数

有些类（如IO类型和unique_ptr）需要阻止拷贝，不定义拷贝控制成员是无效的，会自动生成合成的版本，所以需要=delete，通知编译器我们不希望定义这些成员

对任何函数指定=delete，但是析构函数不可以是，=default只能对可以合成的默认构造函数或拷贝控制成员使用。

拷贝赋值运算符通常执行拷贝构造函数和析构函数的相同的工作

IO类和unique_ptr类可以移动但不能拷贝

可以将一个const的左值引用或者一个右值引用绑定到这类表达式上（返回非引用的函数、、、p471）

右值引用只能绑定到临时对象

- 所用的对象将要被销毁
- 该对象没有其他用户

我们必须在类头文件的声明中和定义中（如果定义在类外的话）都指定noexcept

在移动操作之后，移后源对象必须保持有效、可析构的状态，但是用户不能对齐值进行任何假设

只有当一个类**没有定义**任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符

```
//编译器会为X和hasX合成移动操作
struct X{
	int i;    //内置类型可以移动
	string s;  //string定义了自己的移动操作
};
struct hasX{
	X mem;  //X有合成的移动操作
};
```



定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认被定义为删除的。

```
//假定Y是一个类,它定义了自己的拷贝构造函数但未定义自己的移动构造函数
struct hasY{
	hasY()=default;
	hasY(hasY&&)=default;
	Y mem;//hasY将有一个删除的移动构造函数
};
hasY hy,hy2=std::move(hy);//错误:移动构造函数是删除的
```

```
class HasPtr{
public:
	//添加的移动构造函数
	HasPtr(HasPtr &&p) noexcept : ps(p.ps),i(p.i) {p.ps=0;}
	HasPtr& operator=(HasPtr rhs)
	{
		swap(*this,rhs); return *this;
	}
}
```

移动迭代器的解引用运算符生成一个右值引用

区分移动和拷贝的重载函数通常有一个版本接受一个const T&,而另一个版本接受一个T&&.

引用限定符&或&&,分别指出this可以指向一个左值或一个右值.且必须同时出现在函数的声明和定义中

```
Foo &retFoo();  //返回一个引用;retFoo调用是一个左值
Foo retVal();   //返回一个值;retVal调用是一个右值
Foo i,j;        //i和j是左值
i=j;            //正确:i是左值
retFoo()=j;     //正确:retFoo()返回一个左值
retVal()=j;     //错误:retVal()返回一个右值
i=retVal();     //正确:我们可以将一个右值作为赋值操作的右侧运算对象
```

引用限定符必须跟在const限定符之后

---



***p121***  当一个对象被用作右值的时候,用的是对象的值(内容);当对象被用作左值的时候,用的是对象的身份(在内存中的位置).

使用decltype的时候,左值和右值也有所不同,如果表达式的求值结果是左值,decltype作用于该表达式(不是变量)得到一个引用类型.假定p的类型是int*,因为解引用运算符生成左值,所以decltype( * p)的结果是int&,取地址运算符生成左值,所以decltype(&p)的结果是int**;

---

### 第十四章 重载运算符与类型转换

如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用

后置递增递减操作接受一个额外的（不被使用）int类型的形参

重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象

函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别

lambda是函数对象

```
class ShorterString
{
public:
	bool operator()(const string& a, const string& b) const
    { return a.size() < b.size(); }
};
```

```
	stable_sort(vs.begin(), vs.end(), ShorterString());
```

c++语言中有几种可调用的对象:函数、函数指针、lambda表达式、bind创建的对象以重载了函数调用运算符的类。

调用形式指明了调用返回的类型以及传递给调用的实参类型

如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数。

能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则

---



### 第十五章 面向对象程序设计

函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又称为运行时绑定

在c++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。

每个类控制它自己的成员初始化过程

派生类构造函数首先初始化基类部分（通过调用基类的构造函数来初始化那些从基类继承而来的成员），然后按照声明的顺序依次初始化派生类的成员。

不论丛基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。

如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明

```
class Quote;       //声明但未定义
//错误:Quote必须被定义
class Bulk_quote:public Quote {. . .};
```

类名后跟final,防止继承发生

表达式的静态类型在编译时总时已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知

基类的指针或引用的静态类型可能与其动态类型不一致

不存在从基类向派生类的隐式类型转换

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略

动态绑定只有当我们通过指针或引用调用虚函数时才会发生

当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同

```
struct B{
	virtual void f1(int) const;
	virtual void f2();
	void f3();
};
struct D1:B{
	void f1(int) const override;  //正确:f1与基类中的f1匹配
	void f2(int) override;        //错误:B没有形如f2(int)的函数
	void f3() override;           //错误:
	void f4() override:           //错误:
};
struct D2:B{
	void f1(int) const final;  //不允许后续的其他类覆盖f1(int)
};
struct D3:D2{
	void f2();          //正确:覆盖从间接基类B继承而来的f2
	void f1(int) const; //错误:D2已经将f2声明成final
};
```

如果虚函数使用默认实参,则基类和派生类中定义的默认实参最好一致

通常情况下,只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制

如果一个一个派生类虚函数需要调用ta的基类版本,但是没有使用作用域运算符,则在运行时该调用将被解析为对派生类版本自身的调用,从而导致无限递归

我们可以为纯虚函数提供定义,不过函数体必须定义在类的外部.我们不能在类的内部为一个=0的函数提供函数体

含有纯虚函数的类是抽象基类,我们不能创建抽象基类的对象

派生类的成员或友元只能通过派生类对象来访问基类的受保护成员.派生类对于一个基类对象中的受保护成员没有访问特权

派生访问说明符(就是继承时标注的那个)对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响.对基类成员的访问权限只与基类中的访问说明符(就是基类中标注的)有关

派生访问说明符的目的是控制派生类用户**(包括派生类的派生类在内)对于基类成员的访问权限,(也就是把原本基类里的成员变成了相应派生类自己的权限划分)**

派生访问说明符还可以控制继承自派生类的新类的访问权限

继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数

派生类中删除的拷贝控制与基类的关系p579

```
class B{
public:
B();
B(const B&)=default;
//其他成员,不含有移动构造函数
};
class D : public B{
//没有声明任何构造函数
};
D d;        //正确:D的合成默认构造函数使用B的默认构造函数
D d2(d);    //错误:D的合成拷贝构造函数是被删除的
D d3(std::move(d));  //错误:隐式地使用D的被删除的拷贝构造函数
```

当派生类定义了拷贝或移动操作时，该操作赋值负责拷贝或移动包括基类部分成员在内的整个对象

派生类赋值运算符

```
//Base::operator=(const Base&)不会被自动调用
D& D::operator=(const D &rhs)
{
	Base::operator=(rhs)  //为基类部分赋值
	//按照过去的方式为派生类的成员赋值
	//酌情处理自赋值及释放已有资源等情况
	return *this;
}
```

对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，依次类推，沿着继承体系的反方向直至最后

如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本（如不能在基类的构造函数中调用虚函数的派生类版本，这个派生类版本取访问派生类为初始化的成员）

继承的构造函数，使用using声明语句只是令某个名字在当前作用域内可见，而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数

当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型元素无法兼容

派生类中虚函数的返回类型也必须与基类函数匹配。有个例外，当类的虚函数返回类型是类本身的指针或引用时。比如如果D由B派生得到，则基类的虚函数可以返回B*，而派生类的对应函数可以返回D *

----

### 第十六章 模板与泛型编程

```
template<unsigned N,unsigned M>
int compare(const char (&p1)[N],const char (&p2)[M])
{
	return strcmp(p1,p2);
}
compare("hi","mom")
//实例化出如下版本
int compare(const char (&p1)[3],const char (&p2)[4])
```

非类型模板参数的模板实参必须是常量表达式

函数模板和类模板成员函数的定义通常放在头文件中

定义在类模板内的成员函数被隐式声明为内联函数

默认情况下，对于一个实例化了的类模板，其成员只有在使用时才能实例化

在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参

一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。

```c++
template <typename T>
typename T::value_type top(const T& c)
{
	if(!c.empty())
		return c.back();
	else
	return typename T::value_type();
}
```

当我们希望通知编译器一个名字表示类型时,必须使用关键字typename,而不能使用class

```
template <class T=int> class Numbers{
public:
	Numbers(T v=0):val(v){}
private:
	T val;
};

NUmbers<long double> lots_of_precision;
Numbers<> average_precision;  // 空<>表示我们希望使用默认类型,就是int
```

显式实例化:当编译器遇到extern模板声明时,他不会在本文件中生成实例化代码,这就表示在程序其他位置有该实例化的一个非extern声明.

```
//实例化声明
extern template declaretion;
//实例化定义
template declaration;
```

对每个实例化声明,在程序中某个位置必须有其显式的实例化定义

一个类模板的实例化定义会实例化该模板的所有成员,包括内联函数,所以在一个类模板的实例化定义中,所用类型必须能用于模板的所有成员函数

将实参传递给带模板类型的函数形参时,能够自动应用的类型转换只有const转换及数组或函数到指针的转换

显式模板实参

```
template <typename T1,typename T2,typename T3>
T1 sum(T2,T3);
auto val3=sum<long long>(i,lng)  //long long sum(int,long)
```

```
尾置返回允许我们在参数列表之后声明返回类型
template <typename It>
auto fcn(It beg,It end) -> decltype(*beg)
{
	return *beg;
}
```

如果一个函数参数是指向模板参数类型的右值引用（T&&），则可以传递给他任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&）。

```
template <typename T> void f3(T&& val)
{
	T t=val;//拷贝还是绑定一个引用?
	t=fcn(t);  //赋值只改变t还是即改变t又改变val
	if(val==t){}   //若T是引用类型一直为true
}

f3(42);//字面量42,T为int,t是val的拷贝
f3(i);//若i为左值,则T为int&,t是val的引用,则if一直为true
```

从一个左值static_cast到一个右值引用是允许的

t是string & ,static_cast<string &&>(t),cast将其转换为string&&

我们可以用static_cast显式地将一个左值转换为一个右值引用

 如果一个函数参数是指向模板类型参数的右值引用(如T&&),它对应的实参的const属性和左值/右值属性将得到保持

forward返回该显式实参类型的右值引用。即，forward<T>的返回类型时T&&

当用于一个指向模板参数类型的**右值引用函数参数**(T&&)时,**forward会保持实参类型的所有细节**

当多个重载模板对一个调用提供同样好的匹配时,应选择最特例化的版本

对于一个调用,如果一个非函数模板与一个函数模板提供同样好的匹配时,则选择非模板版本

```
template <typename T> string debug_rep(const T &t);
template <typename T> string debug_rep(T *p);
//以上两个不是在这个文件中的
string debug_rep(const string &);
string debug_rep(char *p)
{
	//如果接受一个const string &的版本的声明不在作用域中,
	//返回语句将调用debug_rep(const T&)的T实例化为string的版本
	return debug_rep(string(p));
}
```

在定义任何函数之前,记得声明所有重载的函数版本.这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本

```
//Args是一个模板参数包,rest是一个函数参数包
//Args表示零个或多个模板类型参数
//rest表示零个或多个函数参数
template <typename T,typename...Args>
void foo(const T &t,const Args&...rest);
cout<<sizeof...(Args)<<endl; //类型参数的数目
cout<<sizeof...(rest)<<endl;//函数参数的数目
```

当定义可变参数版本的print时，非可变参数版本的声明必须在作用域中。否则可变参数版本会无限递归

可变参数函数通常将他们的参数转发给其他函数.

```
//fun有零个或多个参数,每个参数都是一个模板参数类型的右值引用
template<typename... Args>
void fun(Args&&... args)  //将Args扩展为一个右值引用的列表
{
	//work的实参既扩展Args又扩展args
	work(std::forward<Args>(args)...);
}
```

由于fun的参数是右值引用,因此我们可以传递给它任意类型的实参;由于我们使用std::forward传递这些实参,因此它们的所有类型信息在调用work时都会得到保持.

函数模板实例化的本质是实例化一个模板,而非重载它,因此,实例化不影响函数匹配

类模板部分特例化本身是一个模板,我们只能部分特例化类模板,而不能部分特例化函数模板

```
template <typename T> struct Foo{
	Foo(const T &t=T()):mem(t){}
	void Bar(){}
	T mem;
};
template<>   //我们正在特例化一个模板
void Foo<int>::Bar()   //我们正在特例化Foo<int>的成员Bar
{
}
```

#### 关于输出刷新流

1、程序正常结束，作为main函数return操作的一部分，缓冲区被刷新。

2、当缓冲区满了的时候，会刷新缓冲区。

3、可以使用操作符**endl**、**flush**和**ends**来显示的刷新缓冲区。这三个都是IO库中的操作符，endl能完成换行和刷新缓冲区的工作。flush只完成刷新缓冲区的工作。而**ends会向缓冲区插入一个空字符**，**然后刷新缓冲区。**

1、程序正常结束，作为main函数return操作的一部分，缓冲区被刷新。

2、当缓冲区满了的时候，会刷新缓冲区。

3、可以使用操作符endl、flush和ends来显示的刷新缓冲区。这三个都是IO库中的操作符，endl能完成换行和刷新缓冲区的工作。flush只完成刷新缓冲区的工作。而ends会向缓冲区插入一个空字符，然后刷新缓冲区。

```
cout << unitbuf;      //所有的输出操作后都会立即刷新缓冲区
cout << nounitbuf;    //回到正常的缓冲方式
```

一个输出流可能被关联到另一个流。当读写被关联的流时，关联到的流缓冲区会被刷新。默认情况下，cin和cerr都关联到cout。读cin或写cerr都会导致cout的缓冲区被刷新。